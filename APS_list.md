# 배열 

: 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

- 여러 개의 변수가 필요할 때 일일이 접근하지 않아도 됨
- 다수의 변수로 하기 힘든 작업을 쉽게 해결
- 하나의 선언을 통해 여러개의 변수를 선언할 수 있다

### 입력 받은 정수를 1차원 배열에 저장하는 방법
    
    N = int(input())           # 5

    arr = list(map(int, input().split()))  # 1 2 3 4 5


### 배열 원소의 합 계산

    s = 0
    for i in range(N):
        s += arr[i]

## 정렬

: 2개 이상의 자료를 특정 기준에 의해 오름차순 혹은 내림차순으로 재배열 하는 것 

### 버블 정렬

: 인접한 2개의 원소를 비교하며 자리를 계속 교환하는 방식 (시간 복잡도 = O(n <sup>2</sup>))

    def bubble_sort(arr, N) : 	

        for i in range(N-1, 0, -1) :       # 가장 큰 원소가 마지막에 배치되면 탐색할 구간 하나 씩 감소 
            for j in range(i) :	           
                if arr[j] > arr[j+1] :
                    arr[j], arr[j+1] = arr[j+1], arr[j] 

        return arr


1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

### 카운팅 정렬

: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업, 선형 시간 정렬에 효율적 (시간 복잡도 = O(n+k))

    def count_sort(number):

        k = max(number)+1           # 카운트 배열의 길이
        counts = [0]*k
        sort = [0]*len(number)      # 정렬한 숫자의 배열 

        for i in range(len(number)):
            counts[number[i]] += 1

        for i in range(1, k):
            counts[i] += counts[i-1]
        
        for n in number:
            counts[n] -= 1
            sort[counts[n]] = n
        
        return sort

- 제한 사항 : 정수나 정수로 표현할 수 있는 자료에 대해만 적용 가능

1. 받은 배열에서 각 항목들의 발생 횟수를 세고 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장

2. 각 항목의 앞에 위치할 항목의 개수를 카운트 배열에 반영 

3. 받은 배열을 참조하면서 해당 값을 인덱스로 가지는 카운트 항목의 값을 하나씩 감소 시키며 새로운 위치 배열에 할당 (인덱스는 카운트 항목의 값 - 1)

4. 받은 배열의 자료 특성에 따라 뒤에서 부터 참조하는 것도 유효


## 완전 검색

: 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

- 속도는 느리지만 해답을 찾아낼 확률이 매우 높다

- 경우의 수가 적은 경우 유용

- 문제를 풀 때 완전검색으로 접근해 해답을 찾고, 다른 알고리즘으로 성능 개선하는 것도 방법

<Baby-gin Game 문제>

: 고려할 수 있는 모든 경우의 순열을 생성하고 해답 테스트 

### 순열
: 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것 (<sub>n</sub> P <sub>r</sub>)

    for i in range(1, 4):
        for j in range(1, 4):
            if i != j:
                for k in range(1, 4):
                    if k != i and k != j:
                        print(i, j, k)

## 탐욕 알고리즘

: 최적해를 구하는 근시안적인 방법

1. 부분 문제의 최적 해를 구한 뒤 부분해 집합에 추가

2. 새로운 부분해 집합이 실행 가능한지 확인

3. 전체 문재의 해가 되는지 확인
